#### 問題文

頂点数が \\(N\\)、辺の本数が \\(M\\) の重み付き単純無向グラフがあります。
頂点には \\(0\\) から \\(N - 1\\) までの番号がつけられています。
\\(i (1 \le i \le M)\\) 本目の辺は、頂点 \\(u_i\\) と \\(v_i\\) を結び、
その距離は \\(c_i\\) です。

2つの頂点 \\(s\\) と \\(t\\) が与えられるので、
\\(s\\) と \\(t\\) を結ぶ最短経路の距離を出力してください。
\\(s\\) から \\(t\\) への経路が存在しない場合は \\(-1\\) を出力してください。

---

#### 制約

- \\(2 \le N \le 10\\)
- \\(1 \le M \le N \times (N - 1) / 2\\)
- \\(0 \le u_i, v_i < N \\, (1 \le i < M)\\)
- \\(1 \le c_i \le 100 \\, (1 \le i < M)\\)
- \\(0 \le s, t < N\\)

#### 入力

入力は以下の形式でなければならない。

```
N M
u_1 v_1 c_1
...
u_M v_M c_M
s t
```

入力末尾の改行を忘れないこと。

---

#### コード

大学の授業でWarshall-Floydアルゴリズムを学んだ佐藤さんと鈴木くんは、
入力されたグラフを表す隣接行列 \\(D\\) を次のように生成しました。

```kotlin
val INF = 10000000
val D = Array(N) { IntArray(N) { INF } }
for (i in 0 until N) D[i][i] = 0

for (i in 1..M) {
    D[u[i]][v[i]] = c
    D[v[i]][u[i]] = c
}
```

そして、佐藤さんは

```kotlin
for (i in 0 until N) {
    for (j in 0 until N) {
        for (k in 0 until N) {
            D[i][j] = min(D[i][j], D[i][k] + D[k][j])
        }
    }
}
```

というコードを実行しました。一方、鈴木くんは

```kotlin
for (i in 0 until N) {
    for (k in 0 until N) {
        for (j in 0 until N) {
            D[i][j] = min(D[i][j], D[i][k] + D[k][j])
        }
    }
}
```

というコードを実行しました。
二人の実行結果がともに間違ったものになるテストケースを作ってください。
